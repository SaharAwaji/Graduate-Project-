# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FrcjJ_oSu6b4JBvr43v5ITStP4BJei6y
"""

# Library
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
#!pip install streamlit plotly
import streamlit as st
import plotly.express as px

meta_rows2 = [
    {"indicator_id": "EMPLOY_RATE_6_12M", "name": "معدل توظيف الخريجين خلال 6–12 شهرًا", "component_details": "Outcomes-Employment","component": "Outcomes","component": "Outcomes", "weight": 0.18, "function": "Lagging", "goal": 4, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "EMPLOYER_SATISFACTION", "name": "معدل رضا أصحاب العمل عن الخريجين", "component_details": "Outcomes-Employment","component": "Outcomes", "weight": 0.14, "function": "Concurrent", "goal": 1, "direction": "HigherIsBetter", "is_likert": True},
    {"indicator_id": "PROGRAMS_INTL_RANKED", "name": "نسبة البرامج المصنفة دوليًا", "component_details": "Outcomes-Employment","component": "Outcomes",  "weight": 0.03, "function": "Leading", "goal": 1, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "CAREER_SERVICES", "name": "عدد المشاريع الريادية المحتضنة/المعتمدة", "component_details": "Outcomes-Innovation& entrepreneurship", "component": "Outcomes", "weight": 0.04, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "PATENT_COUNT", "name": "عدد براءات الاختراع", "component_details": "Outcomes-Innovation& entrepreneurship","component": "Outcomes", "weight": 0.02, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "BIZ_PARTNERSHIPS", "name": "نسبة الطلبة في برامج STEMM (مع الصحة)", "component_details": "Processes- Education&traning",  "component": "Processess","weight": 0.04, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "NATIONAL_PROF_EXAMS", "name": "معدل الأداء الأكاديمي في مواد التخصص الأساسية", "component_details": "Processes- Education&traning", "component": "Processess", "weight": 0.06, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "LINKEDIN_ACTIVE", "name": "معدل التخرج في الوقت المحدد", "component_details": "Processes- Education&traning", "component": "Processess", "weight": 0.06, "function": "Lagging", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "WAGE_GROWTH_1Y", "name": "نسبة النجاح في الاختبارات المعيارية الموحدة", "component_details": "Processes- Education&traning",  "component": "Processess","weight":0.06, "function": "Lagging", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "FOUNDERS_RATE", "name": "نتائج الاختبارات الوطنية/المهنية", "component_details": "Processes- Education&traning", "component": "Processess", "weight": 0.05, "function": "Lagging", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "PROMOTION_RATE", "name": "دعم الخريجين بخدمات الإرشاد المهني", "component_details": "Processes- Support & empowerment", "component": "Processess", "weight": 0.04, "function": "Leading", "goal": 1, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "JOB_STABILITY_2Y", "name": "نسبة البرامج المشتركة مع قطاع الأعمال", "component_details": "Processes- Support & empowerment",  "component": "Processess","weight": 0.1, "function": "Leading", "goal": 1, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "STEMM_SHARE", "name": "نسبة الطلبة المشاركين في مبادرات الابتكار", "component_details": "Processes- Support & empowerment", "component": "Processess", "weight": 0.04, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "ACCRED_PROGS", "name": "رضا الطلبة عن العملية التعليمية", "component_details": "Processes- Support & empowerment", "component": "Processess", "weight": 0.03, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "INTERN_RATE", "name": "رضا الطلبة عن الخدمات المساندة", "component_details": "Processes- Support & empowerment", "component": "Processess", "weight": 0.03, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "ENTRE_SUPPORT", "name": "البرامج الأكاديمية المعززة لمفهوم ريادة الأعمال", "component_details": "Processes-Supportive academic programs","component": "Processes", "weight": 0.03, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "FUNDING_SHARE", "name": "البرامج المدمجة بمهارات القرن 21", "component_details": "Processes-Supportive academic programs",  "component": "Processess","weight": 0.03, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "STUDENT_SAT", "name": "البرامج المدمجة بمفاهيم الاستدامة", "component_details": "Processes-Supportive academic programs", "component": "Processess","weight": 0.03, "function": "Leading", "goal": 3, "direction": "HigherIsBetter", "is_likert": True},
    {"indicator_id": "GRAD_SAT", "name": "السجل المهاري (Skills Portfolio)", "component_details": "Conceptual-Human","component": "Conceptual",  "weight": 0.02, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": True},
    {"indicator_id": "SKILL_DEV", "name": "الشهادات الاحترافية", "component_details": "Conceptual-Human", "component": "Conceptual", "weight": 0.02, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": True},
    {"indicator_id": "RESEARCH_PUBS", "name": "المشاركة في المؤتمرات/المسابقات", "component_details": "Conceptual-Human","component": "Conceptual",  "weight": 0.02, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "INTERNATIONAL_STUD", "name": "المشاركة في الأندية الطلابية", "component_details": "Conceptual-Social &professional", "component": "Conceptual", "weight": 0.01, "function": "Leading", "goal": 1, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "FACULTY_INTL", "name": "المشاركة في التطوع وخدمة المجتمع", "component_details": "Conceptual-Social &professional","component": "Conceptual",  "weight": 0.01, "function": "Leading", "goal": 1, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "MOBILITY", "name": "الحسابات المهنية النشطة (LinkedIn)", "component_details": "Conceptual-Social &professional", "component": "Conceptual", "weight": 0.04, "function": "Leading", "goal": 1, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "NATIONAL_PART", "name": "كفاءة اللغة الإنجليزية أو لغات أجنبية", "component_details": "Conceptual-Human", "component": "Conceptual", "weight": 0.02, "function": "Concurrent", "goal": 2, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "CURRICULUM_UPD", "name": "متوسط نسبة الزيادة في الرواتب بعد سنة", "component_details": "Impact","component": "Impact",  "weight": 0.12, "function": "Lagging", "goal": 4, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "ENTRE_SUPPORT", "name": "نسبة الخريجين المؤسسين لمشاريع ريادية", "component_details": "Impact","component": "Impact",  "weight": 0.06, "function": "Lagging", "goal": 4, "direction": "HigherIsBetter", "is_likert": False},
    {"indicator_id": "EMPLOYABILITY_SKILL", "name": "معدل الترقيات الوظيفية للخريجين", "component_details": "Impact", "component": "Impact", "weight": 0.06, "function": "Lagging", "goal": 4, "direction": "HigherIsBetter", "is_likert": True},
    {"indicator_id": "COMM_SKILLS", "name": "الاستقرار الوظيفي", "component_details": "Impact","component": "Impact",  "weight": 0.06, "function": "Lagging", "goal": 4, "direction": "HigherIsBetter", "is_likert": True},
    {"indicator_id": "DIGITAL_SKILLS", "name": "السمعة المجتمعية لمخرجات الجامعة", "component_details": "Impact","component": "Impact",  "weight": 0.04, "function": "Lagging", "goal": 1, "direction": "HigherIsBetter", "is_likert": True},
]

indicators_meta2 = pd.DataFrame(meta_rows2)
#indicators_meta2

goal_map = {
    1: "التنسيق الوطني",
    2: "تمكين الموارد والخدمات",
    3: "التطوير والابتكار في البرامج",
    4: "القياس والأثر"
}

# إضافة العمود الجديد
indicators_meta2["goal_name"] = indicators_meta2["goal"].map(goal_map)

# عرض أول 5 صفوف للتأكد
#print(indicators_meta2.head())
indicators_meta2

# إعادة التطبيع بحيث يكون المجموع = 1
indicators_meta2["weight"] = indicators_meta2["weight"] / indicators_meta2["weight"].sum()

# التحقق بعد التطبيع
print("المجموع الجديد =", indicators_meta2["weight"].sum())

indicators_meta2

# # ملء القيم الفارغة بالمتوسط
# # mean_weight = indicators_meta['weight'].mean()
# # indicators_meta['weight'] = indicators_meta2['weight'].fillna(mean_weight)

# # # تطبيع الأوزان
# # indicators_meta['weight'] = indicators_meta['weight'] / indicators_meta['weight'].sum()

# def weighted_mean(values, weights):
#     values = np.asarray(values, dtype=float)
#     weights = np.asarray(weights, dtype=float)
#     if np.all(np.isnan(weights)) or np.nansum(weights) == 0:
#         return float(np.nanmean(values))
#     return float(np.nansum(values * weights) / np.nansum(weights))

np.random.seed(42)
years = [2021, 2022, 2023, 2024]
universities = ["UniA", "UniB", "UniC"]

def likert_to_100(x): return ((x - 1) / 4.0) * 100.0

def minmax_0_100(series, higher_is_better=True):
    s = series.astype(float)
    vmin, vmax = s.min(), s.max()
    norm = (s - vmin) / (vmax - vmin) * 100.0 if vmax > vmin else pd.Series(50.0, index=s.index)
    return norm if higher_is_better else 100.0 - norm


def slope(series):
    years_sorted = sorted(series.keys())
    diffs = [series[b]-series[a] for a,b in zip(years_sorted[:-1], years_sorted[1:])]
    return np.mean(diffs) if diffs else np.nan

def classify_trend(s):
    if pd.isna(s): return "N/A"
    if s >= 5: return "Strong Uptrend"
    if 2 <= s < 5: return "Mild Uptrend"
    if -1.9 <= s <= 1.9: return "Flat"
    if -5 < s < -2: return "Mild Downtrend"
    if s <= -5: return "Strong Downtrend"
    return "Flat"


# -----------------------------
# 3) محاكاة بيانات خام
# -----------------------------
raw = []
rng = np.random.default_rng(2025)
for uni in universities:
    for y in years:
        for _, row in indicators_meta2.iterrows():
            if row["is_likert"]:
                val = rng.uniform(2.5, 4.7)  # ليكرت 1–5
            else:
                val = rng.uniform(40, 95)    # نسب مئوية
            raw.append((uni, y, row["indicator_id"], val))
raw_df = pd.DataFrame(raw, columns=["university","year","indicator_id","raw_value"])

# -----------------------------
# 4) التطبيع
# -----------------------------
norm_rows = []
for ind, sub in raw_df.groupby("indicator_id"):
    meta = indicators_meta2[indicators_meta2["indicator_id"]==ind].iloc[0]
    higher = (meta["direction"] != "LowerIsBetter")
    sub = sub.copy()
    if meta["is_likert"]:
        sub["norm_0_100"] = likert_to_100(sub["raw_value"])
    else:
        sub["norm_0_100"] = minmax_0_100(sub["raw_value"], higher)
    norm_rows.append(sub)
norm_df = pd.concat(norm_rows)

# -----------------------------
# 5) تجميع المستويات
# -----------------------------
merged = norm_df.merge(indicators_meta2,on="indicator_id")
#merged["weight"] = merged["weight"].fillna(0.0)

def aggregate(df, by_cols):
    grouped = []
    for keys, sub in df.groupby(by_cols):
        w = sub["weight"] if "weight" in sub else pd.Series([np.nan]*len(sub))
        v = sub["norm_0_100"].values
        # إذا ما فيه أي وزن → متوسط بسيط
        if w.notna().any():
            val = np.nansum(v * np.nan_to_num(w)) / np.nansum(np.nan_to_num(w))
        else:
            val = np.nanmean(v)
        rec = dict(zip(by_cols, keys if isinstance(keys, tuple) else (keys,)))
        rec["score"] = val
        grouped.append(rec)
    return pd.DataFrame(grouped)

func_level = aggregate(merged, ["university","year","goal","function"])
goal_level = aggregate(func_level.rename(columns={"score":"norm_0_100"}), ["university","year","goal"])
overall = aggregate(goal_level.rename(columns={"score":"norm_0_100"}), ["university","year"]).rename(columns={"score":"overall_index_0_100"})

# -----------------------------
# 6) إشارات الـ Leading
# -----------------------------
lead = func_level[func_level["function"]=="Leading"]
signals=[]
for (uni,goal),sub in lead.groupby(["university","goal"]):
    s = slope({int(r["year"]):float(r["score"]) for _,r in sub.iterrows()})
    signals.append({"university":uni,"goal":goal,"slope":s,"trend":classify_trend(s),
                    "signal":"Early Signal" if s>=2 else ("Early Warning" if s<=-2 else "Neutral")})
signals_df = pd.DataFrame(signals)

# -----------------------------
# 7) رسوم
# -----------------------------
latest=max(years)
bar=goal_level[goal_level["year"]==latest].pivot(index="goal",columns="university",values="score")
bar.plot(kind="bar",title=f"Goal Scores {latest}"); plt.ylabel("0–100"); plt.show()

for uni in universities:
    mat=goal_level[goal_level["university"]==uni].pivot(index="goal",columns="year",values="score")
    plt.imshow(mat.values,aspect="auto"); plt.colorbar(label="0–100")
    plt.title(f"Heatmap - {uni}"); plt.xticks(range(len(mat.columns)),mat.columns); plt.yticks(range(len(mat.index)),mat.index)
    plt.show()

# -----------------------------
# 8) حفظ ملف Excel
# -----------------------------
# with pd.ExcelWriter("simulation_results.xlsx",engine="xlsxwriter") as writer:
#     indicators_meta.to_excel(writer,index=False,sheet_name="indicators_meta")
#     raw_df.to_excel(writer,index=False,sheet_name="raw_data")
#     norm_df.to_excel(writer,index=False,sheet_name="normalized")
#     func_level.to_excel(writer,index=False,sheet_name="func_level")
#     goal_level.to_excel(writer,index=False,sheet_name="goal_level")
#     overall.to_excel(writer,index=False,sheet_name="overall_index")
#     signals_df.to_excel(writer,index=False,sheet_name="leading_signals")

# --------------------------
# حساب المؤشر الكلي لكل نوع
# --------------------------
np.random.seed(42)
if 'value' not in indicators_meta2.columns:
    indicators_meta2['value'] = np.random.rand(len(indicators_meta2))

indices_df = indicators_meta2.groupby('function').apply(
    lambda x: (x['value'] * x['weight']).sum()
).reset_index(name='Index')

# إضافة المؤشر الكلي
overall_index = indices_df['Index'].sum()
indices_df = pd.concat([indices_df, pd.DataFrame([{'function': 'Overall', 'Index': overall_index}])], ignore_index=True)

print(indices_df)

plt.figure(figsize=(10,6))
colors = {'Leading':'#FFA500', 'Concurrent':'#00BFFF', 'Lagging':'#32CD32', 'Overall':'#FF69B4'}
plt.bar(indices_df['function'], indices_df['Index'], color=[colors[t] for t in indices_df['function']])
plt.title("Overall Index of Graduate Readiness")
plt.ylabel("Weighted Index")
plt.ylim(0, 1)  # إذا القيم بين 0 و 1
plt.show()

# --------------------------
# افتراض: لديك DataFrame باسم indicators_meta
# يحتوي الأعمدة:
# 'indicator_id', 'name', 'weight', 'value', 'type' (Leading / Concurrent / Lagging)
# --------------------------

# مثال للقيم إذا لم تكن موجودة
np.random.seed(42)
if 'value' not in indicators_meta2.columns:
    indicators_meta['value'] = np.random.rand(len(indicators_meta2))

# --------------------------
# حساب المؤشر الفردي بعد الوزن
# --------------------------
indicators_meta2['weighted_value'] = indicators_meta2['value'] * indicators_meta2['weight']

# --------------------------
# حساب المؤشر الكلي لكل نوع
# --------------------------
type_index = indicators_meta2.groupby('function')['weighted_value'].sum().reset_index()
overall_index = type_index['weighted_value'].sum()
type_index = pd.concat([type_index, pd.DataFrame([{'function':'Overall', 'weighted_value':overall_index}])], ignore_index=True)

# --------------------------
# رسم كل مؤشر فردي مع لون حسب النوع
# --------------------------
plt.figure(figsize=(16,6))
colors = {'Leading':'#FFA500', 'Concurrent':'#00BFFF', 'Lagging':'#32CD32'}

plt.bar(indicators_meta2['indicator_id'], indicators_meta2['weighted_value'],
        color=[colors[t] for t in indicators_meta2['function']]) # Corrected 'type' to 'function'
plt.xticks(rotation=90)
plt.ylabel("Weighted Value")
plt.title("Individual Indicators Weighted Values by Type")
plt.show()

# --------------------------
# رسم المؤشر الكلي لكل نوع + Overall
# --------------------------
plt.figure(figsize=(8,6))
colors_total = {'Leading':'#FFA500', 'Concurrent':'#00BFFF', 'Lagging':'#32CD32', 'Overall':'#FF69B4'}
plt.bar(type_index['function'], type_index['weighted_value'], color=[colors_total[t] for t in type_index['function']])
plt.ylabel("Weighted Index")
plt.title("Overall Index by Indicator Type")
plt.ylim(0, 1)
plt.show()

# --------------------------
# طباعة القيم للرجوع إليها
# --------------------------
print("Weighted values for individual indicators:")
print(indicators_meta2[['indicator_id','name','function','weighted_value']])
#print(indicators_meta[['indicator_id','name','function','weighted_value']])

print("\nOverall Index by Type:")
print(type_index)

# st.set_page_config(page_title="Overall Graduate Readiness Index", layout="wide")
# st.title("📈 الداشبورد الأول: المؤشر الكلي لجاهزية الخريجين")
# st.caption("Gauge للمؤشر الكلي • Pie لمساهمة الأنواع • Trend عبر السنوات")

# # ------------------------------------------------
# # تحميل النتائج من الكود اللي كتبته فوق (مثلاً signals_df, overall, goal_level)
# # هنا افترض انك جهزتها قبل
# # ------------------------------------------------

# # عنوان رئيسي
# st.title("📊 لوحة متابعة مؤشرات المحاكاة (3-4 سنوات)")

# # اختيار الجامعة والهدف
# uni_choice = st.selectbox("اختر الجامعة:", overall["university"].unique())
# goal_choice = st.selectbox("اختر الهدف:", goal_level["goal"].unique())

# # -----------------------------
# # 1) المؤشر الكلي
# # -----------------------------
# st.subheader("📈 المؤشر الكلي")
# fig_overall = px.line(overall[overall["university"]==uni_choice],
#                       x="year", y="overall_index_0_100", title="المؤشر الكلي للجامعة")
# st.plotly_chart(fig_overall)

# # -----------------------------
# # 2) مؤشرات الأهداف
# # -----------------------------
# st.subheader("🎯 مؤشرات على مستوى الأهداف")
# goal_sub = goal_level[(goal_level["university"]==uni_choice)]
# fig_goal = px.line(goal_sub, x="year", y="score", color="goal", markers=True,
#                    title=f"تطور الأهداف للجامعة {uni_choice}")
# st.plotly_chart(fig_goal)

# # -----------------------------
# # 3) اتجاهات وإشارات مبكرة
# # -----------------------------
# st.subheader("🚦 الاتجاهات وإشارات الإنذار المبكر")
# signal_sub = signals_df[signals_df["university"]==uni_choice]
# st.dataframe(signal_sub)

# # -----------------------------
# # 4) تفصيل على مستوى المؤشرات
# # -----------------------------
# st.subheader(f"📑 تفاصيل المؤشرات للهدف {goal_choice}")
# func_sub = func_level[(func_level["university"]==uni_choice) & (func_level["goal"]==goal_choice)]
# fig_func = px.line(func_sub, x="year", y="score", color="function", markers=True,
#                    title=f"تطور المؤشرات (Leading, Concurrent, Lagging) للهدف {goal_choice}")
# st.plotly_chart(fig_func)

import plotly.graph_objects as go

# st.set_page_config(page_title="Overall Graduate Readiness Index", layout="wide")
# st.title("📈 الداشبورد الأول: المؤشر الكلي لجاهزية الخريجين")
# st.caption("Gauge للمؤشر الكلي • Pie لمساهمة الأنواع • Trend عبر السنوات")

# # =========================
# # 0) محاولة الاعتماد على جداولك؛ وإن لم تتوفر نصنع بيانات تجريبية
# # =========================


# def weighted_mean(values, weights):
#     values = np.asarray(values, dtype=float)
#     weights = np.asarray(weights, dtype=float)
#     if np.all(np.isnan(weights)) or np.nansum(weights) == 0:
#         return float(np.nanmean(values))
#     return float(np.nansum(values * weights) / np.nansum(weights))

# def build_demo():
#     rng = np.random.default_rng(42)
#     # 30 مؤشر موزعة: 8 Leading / 7 Concurrent / 15 Lagging
#     kinds = (["Leading"]*8) + (["Concurrent"]*7) + (["Lagging"]*15)
#     weights = rng.uniform(0.5, 2.0, size=30)
#     weights = weights / weights.sum()
#     rows = []
#     for i in range(30):
#         rows.append({
#             "indicator_id": f"IND_{i+1:02d}",
#             "name": f"Indicator {i+1}",
#             "component_details": "",
#             "component": "",
#             "weight": weights[i],
#             "function": kinds[i],
#             "goal": rng.integers(1, 5),
#             "direction": "HigherIsBetter",
#             "is_likert": bool(rng.random() < 0.25),
#         })
#     indicators_meta2 = pd.DataFrame(rows)

#     universities = ["UniA", "UniB", "UniC"]
#     years = [2021, 2022, 2023, 2024]
#     raw = []
#     for u in universities:
#         for y in years:
#             for _, r in indicators_meta2.iterrows():
#                 val = rng.uniform(2.5, 4.7) if r["is_likert"] else rng.uniform(40, 95)
#                 raw.append((u, y, r["indicator_id"], val))
#     raw_df = pd.DataFrame(raw, columns=["university","year","indicator_id","raw_value"])

#     # تطبيع إلى 0–100 لكل مؤشر
#     norm_blocks = []
#     for ind, sub in raw_df.groupby("indicator_id"):
#         meta = indicators_meta2.loc[indicators_meta2["indicator_id"]==ind].iloc[0]
#         sub = sub.copy()
#         if meta["is_likert"]:
#             sub["norm_0_100"] = likert_to_100(sub["raw_value"])
#         else:
#             sub["norm_0_100"] = minmax_0_100(sub["raw_value"], higher_is_better=(meta["direction"]!="LowerIsBetter"))
#         norm_blocks.append(sub)
#     norm_df = pd.concat(norm_blocks, ignore_index=True)

#     merged = norm_df.merge(indicators_meta2, on="indicator_id", how="left")

#     def aggregate(df, by_cols):
#         grouped = []
#         for keys, s in df.groupby(by_cols):
#             w = s["weight"] if "weight" in s else pd.Series([np.nan]*len(s))
#             v = s["norm_0_100"].values
#             val = weighted_mean(v, w)
#             rec = dict(zip(by_cols, keys if isinstance(keys, tuple) else (keys,)))
#             rec["score"] = val
#             grouped.append(rec)
#         return pd.DataFrame(grouped)

#     func_level = aggregate(merged, ["university","year","goal","function"])
#     goal_level = aggregate(func_level.rename(columns={"score":"norm_0_100"}), ["university","year","goal"])
#     overall = aggregate(goal_level.rename(columns={"score":"norm_0_100"}), ["university","year"]).rename(columns={"score":"overall_index_0_100"})

#     return indicators_meta2, raw_df, func_level, goal_level, overall

# # جرّب أخذ الجداول من بيئة التشغيل (إن كانت موجودة)
# g = globals()
# need_demo = False
# try:
#     indicators_meta2 = g["indicators_meta2"]
#     raw_df = g["raw_df"]
#     func_level = g["func_level"]
#     goal_level = g["goal_level"]
#     overall = g["overall"]
# except KeyError:
#     need_demo = True

# if need_demo:
#     indicators_meta2, raw_df, func_level, goal_level, overall = build_demo()

# # =========================
# # 1) المرشّحات
# # =========================
# left, right = st.columns([1,1])
# with left:
#     universities = sorted(overall["university"].unique().tolist())
#     uni = st.selectbox("اختر الجامعة", universities, index=0)
# with right:
#     years = sorted(overall["year"].unique().tolist())
#     year_start, year_end = st.select_slider("نطاق السنوات للترند", options=years, value=(years[0], years[-1]))

# current_year = year_end

# # اطارات مرشّحة
# overall_f = overall[(overall["university"]==uni)]
# func_f = func_level[(func_level["university"]==uni)]

# # حساب مساهمة الأنواع لسنة معيّنة (باستخدام مجموع الأوزان داخل النوع كحصة من الكلي)
# # نجمع الأوزان من meta على مستوى النوع:
# type_weights = indicators_meta2.groupby("function", as_index=False)["weight"].sum().rename(columns={"weight":"w_sum"})

# # درجة النوع = متوسط مرجّح (محسوب مسبقًا في func_level.score)؛
# # سنستخدم w_sum فقط لعرض "نسبة المساهمة" داخل الكلي.
# type_score_now = func_f[func_f["year"]==current_year].groupby("function", as_index=False)["score"].mean()
# type_breakdown = type_weights.merge(type_score_now, on="function", how="left").fillna({"score":0})

# # المؤشر الكلي لسنة العرض
# overall_now = overall_f[overall_f["year"]==current_year]["overall_index_0_100"]
# overall_now = float(overall_now.iloc[0]) if len(overall_now) else np.nan

# # =========================
# # 2) Visualization
# # =========================
# c1, c2 = st.columns([1,1])

# # 2.1 Gauge (Speedometer) للمؤشر الكلي
# with c1:
#     st.subheader("المؤشر الكلي (0–100)")
#     if pd.notna(overall_now):
#         gauge = go.Figure(go.Indicator(
#             mode="gauge+number",
#             value=overall_now,
#             number={"suffix":" / 100"},
#             title={"text": f"Overall Index – {uni} ({current_year})"},
#             gauge={
#                 "axis":{"range":[0,100]},
#                 "bar":{"thickness":0.2},
#                 "steps":[
#                     {"range":[0,50],"color":"#fce4e4"},
#                     {"range":[50,75],"color":"#fff3cd"},
#                     {"range":[75,100],"color":"#e8f5e9"},
#                 ]
#             }
#         ))
#         gauge.update_layout(height=360, margin=dict(l=20,r=20,t=50,b=10))
#         st.plotly_chart(gauge, use_container_width=True)
#     else:
#         st.warning("لا توجد قيمة متاحة للمؤشر الكلي في السنة المحددة.")

# # 2.2 Pie – مساهمة الأنواع داخل الكلي (حسب مجموع الأوزان)
# with c2:
#     st.subheader("مساهمة الأنواع داخل المؤشر الكلي")
#     pie_df = type_breakdown.copy()
#     pie_df["function"] = pie_df["function"].map({
#         "Leading":"Leading (إنذار مبكر)",
#         "Concurrent":"Concurrent (تشخيص فوري)",
#         "Lagging":"Lagging (قياس أثر)"
#     }).fillna(pie_df["function"])

#     pie = px.pie(pie_df, names="function", values="w_sum", hole=0.45,
#                  title=f"توزيع الأوزان حسب النوع – {uni}")
#     pie.update_layout(legend_title="", height=360, margin=dict(l=10,r=10,t=60,b=10))
#     st.plotly_chart(pie, use_container_width=True)

# # 2.3 Trend line – تطور المؤشر الكلي عبر السنوات
# st.markdown("### الترند الزمني للمؤشر الكلي")
# trend = overall_f[(overall_f["year"]>=year_start) & (overall_f["year"]<=year_end)].sort_values("year")
# if not trend.empty and trend["overall_index_0_100"].notna().any():
#     line = px.line(trend, x="year", y="overall_index_0_100", markers=True,
#                    title=f"تطور المؤشر الكلي – {uni}")
#     line.update_layout(yaxis_title="المؤشر الكلي (0–100)", xaxis_title="السنة")
#     st.plotly_chart(line, use_container_width=True)
# else:
#     st.info("لا توجد بيانات كافية لعرض الترند في النطاق المحدد.")

# # =========================
# # 3) لقطات تفسيرية
# # =========================
# with st.expander("ماذا يعني هذا الداشبورد؟"):
#     st.markdown("""
# - **المؤشر الكلي (Gauge)**: درجة جاهزية الخريجين على مقياس 0–100 بعد **تطبيع** المؤشرات الفردية وتجميعها بوزن كل مؤشر.
# - **مساهمة الأنواع (Pie)**: تعطيك **هيكل المؤشر**—كم يشكّل **Leading/Concurrent/Lagging** من الوزن الكلي؛
#   هذا يساعد في فهم: هل المؤشر يعتمد أكثر على إشارات مبكرة أم على مؤشرات أثر لاحقة؟
# - **الترند الزمني (Line)**: يوضّح **مسار التحسّن أو التراجع** عبر السنوات لقياس الاستدامة وليس لقطة لحظية فقط.
#     """)

st.set_page_config(page_title="Overall Graduate Readiness Index", layout="wide")
st.title("📈 الداشبورد الأول: المؤشر الكلي لجاهزية الخريجين")
st.caption("Gauge للمؤشر الكلي • Pie لمساهمة الأنواع • Trend عبر السنوات • 👨‍🎓 عدّاد الطلاب")

# =========================
# 0) دوال مساعدة + بيانات افتراضية عند الحاجة
# =========================
def likert_to_100(x):
    return ((x - 1.0) / 4.0) * 100.0  # 1..5 -> 0..100

def minmax_0_100(series, higher_is_better=True):
    s = series.astype(float)
    mn, mx = s.min(), s.max()
    scaled = (s - mn) / (mx - mn) * 100.0 if mx > mn else pd.Series(50.0, index=s.index)
    return scaled if higher_is_better else 100.0 - scaled

def weighted_mean(values, weights):
    values = np.asarray(values, dtype=float)
    weights = np.asarray(weights, dtype=float)
    if np.all(np.isnan(weights)) or np.nansum(weights) == 0:
        return float(np.nanmean(values))
    return float(np.nansum(values * weights) / np.nansum(weights))

def build_demo():
    rng = np.random.default_rng(42)
    # 30 مؤشر: 8 Leading / 7 Concurrent / 15 Lagging
    kinds = (["Leading"]*8) + (["Concurrent"]*7) + (["Lagging"]*15)
    weights = rng.uniform(0.5, 2.0, size=30); weights = weights / weights.sum()
    rows = []
    for i in range(30):
        rows.append({
            "indicator_id": f"IND_{i+1:02d}",
            "name": f"Indicator {i+1}",
            "component_details": "",
            "component": "",
            "weight": weights[i],
            "function": kinds[i],
            "goal": rng.integers(1, 5),
            "direction": "HigherIsBetter",
            "is_likert": bool(rng.random() < 0.25),
        })
    indicators_meta2 = pd.DataFrame(rows)

    universities = ["UniA", "UniB", "UniC"]
    years = [2021, 2022, 2023, 2024]
    raw = []
    for u in universities:
        for y in years:
            for _, r in indicators_meta2.iterrows():
                val = rng.uniform(2.5, 4.7) if r["is_likert"] else rng.uniform(40, 95)
                raw.append((u, y, r["indicator_id"], val))
    raw_df = pd.DataFrame(raw, columns=["university","year","indicator_id","raw_value"])

    # تطبيع 0–100 لكل مؤشر
    norm_blocks = []
    for ind, sub in raw_df.groupby("indicator_id"):
        meta = indicators_meta2.loc[indicators_meta2["indicator_id"]==ind].iloc[0]
        sub = sub.copy()
        if meta["is_likert"]:
            sub["norm_0_100"] = likert_to_100(sub["raw_value"])
        else:
            sub["norm_0_100"] = minmax_0_100(sub["raw_value"], higher_is_better=(meta["direction"]!="LowerIsBetter"))
        norm_blocks.append(sub)
    norm_df = pd.concat(norm_blocks, ignore_index=True)

    merged = norm_df.merge(indicators_meta2, on="indicator_id", how="left")

    def aggregate(df, by_cols):
        grouped = []
        for keys, s in df.groupby(by_cols):
            w = s["weight"] if "weight" in s else pd.Series([np.nan]*len(s))
            v = s["norm_0_100"].values
            val = weighted_mean(v, w)
            rec = dict(zip(by_cols, keys if isinstance(keys, tuple) else (keys,)))
            rec["score"] = val
            grouped.append(rec)
        return pd.DataFrame(grouped)

    func_level = aggregate(merged, ["university","year","goal","function"])
    goal_level = aggregate(func_level.rename(columns={"score":"norm_0_100"}), ["university","year","goal"])
    overall = aggregate(goal_level.rename(columns={"score":"norm_0_100"}), ["university","year"]).rename(columns={"score":"overall_index_0_100"})

    # طلاب تجريبي: توزيع عشوائي واقعي
    srows = []
    for y in years:
        # إجمالي وطني تقريبي لكل سنة
        national_total = int(rng.integers(24000, 36000))
        # نسب الجامعات
        shares = rng.random(3); shares = shares / shares.sum()
        for u, sh in zip(universities, shares):
            srows.append((u, y, int(national_total * sh)))
    students_df = pd.DataFrame(srows, columns=["university","year","students"])

    return indicators_meta2, raw_df, func_level, goal_level, overall, students_df

g = globals()
need_demo = False
try:
    indicators_meta2 = g["indicators_meta2"]
    raw_df = g["raw_df"]
    func_level = g["func_level"]
    goal_level = g["goal_level"]
    overall = g["overall"]
except KeyError:
    need_demo = True

if need_demo:
    indicators_meta2, raw_df, func_level, goal_level, overall, students_df = build_demo()
else:
    # لو عندنا ملف طلاب نقدر نقرأه من هنا:
    students_file = st.sidebar.file_uploader("📥 حمّل ملف الطلاب (students.csv)", type=["csv"])
    if students_file is not None:
        students_df = pd.read_csv(students_file)
    else:
        # في حال ما عندنا ملف زي حالتنا الحين، نصنع داتا افتراضية من الجامعات/السنوات المتاحة
        _, _, _, _, _, students_df = build_demo()

# =========================
# 1) المرشّحات
# =========================
left, right = st.columns([1,1])
with left:
    universities = sorted(overall["university"].unique().tolist())
    uni = st.selectbox("اختر الجامعة", universities, index=0)
with right:
    years = sorted(overall["year"].unique().tolist())
    year_start, year_end = st.select_slider("نطاق السنوات للترند", options=years, value=(years[0], years[-1]))

current_year = year_end

# اطارات مرشّحة
overall_f = overall[(overall["university"]==uni)]
func_f = func_level[(func_level["university"]==uni)]

# مساهمة الأنواع (حسب مجموع الأوزان)
type_weights = indicators_meta2.groupby("function", as_index=False)["weight"].sum().rename(columns={"weight":"w_sum"})
type_score_now = func_f[func_f["year"]==current_year].groupby("function", as_index=False)["score"].mean()
type_breakdown = type_weights.merge(type_score_now, on="function", how="left").fillna({"score":0})

# قيمة المؤشر الكلي
overall_now = overall_f[overall_f["year"]==current_year]["overall_index_0_100"]
overall_now = float(overall_now.iloc[0]) if len(overall_now) else np.nan

# =========================
# 2) 👨‍🎓 قسم عدّاد الطلاب
# =========================
st.markdown("### 👨‍🎓 الطلاب")
# تصفية الطلاب حسب نطاق السنوات
students_in_range = students_df[(students_df["year"]>=year_start) & (students_df["year"]<=year_end)]
# إجمالي الطلاب (وطني) داخل النطاق
national_total_range = int(students_in_range["students"].sum())
# طلاب الجامعة المختارة في السنة الحالية
uni_current_students = int(
    students_df[(students_df["university"]==uni) & (students_df["year"]==current_year)]["students"].sum()
) if not students_df.empty else 0

m1, m2, m3 = st.columns(3)
with m1:
    st.metric("إجمالي الطلاب (في النطاق المختار)", f"{national_total_range:,}")
with m2:
    st.metric(f"طلاب {uni} في {current_year}", f"{uni_current_students:,}")
with m3:
    # حصة الجامعة من الإجمالي في نفس السنة
    national_current_total = int(students_df[students_df["year"]==current_year]["students"].sum())
    share = (uni_current_students / national_current_total * 100.0) if national_current_total>0 else 0.0
    st.metric("حصة الجامعة من إجمالي السنة", f"{share:.1f}%")

# توزيع الطلاب على الجامعات في السنة الحالية
st.write(f"**توزيع الطلاب حسب الجامعة – {current_year}**")
students_current_year = students_df[students_df["year"]==current_year].copy()
if not students_current_year.empty:
    bar_students = px.bar(students_current_year, x="university", y="students", text="students",
                          title=f"عدد الطلاب حسب الجامعة ({current_year})")
    bar_students.update_layout(yaxis_title="عدد الطلاب", xaxis_title="الجامعة")
    bar_students.update_traces(texttemplate="%{text:,}", textposition="outside")
    st.plotly_chart(bar_students, use_container_width=True)
else:
    st.info("لا توجد بيانات طلاب للسنة الحالية.")

# =========================
# 3) Visualization المؤشر الكلي
# =========================
c1, c2 = st.columns([1,1])

# 3.1 Gauge (Speedometer) للمؤشر الكلي
with c1:
    st.subheader("المؤشر الكلي (0–100)")
    if pd.notna(overall_now):
        gauge = go.Figure(go.Indicator(
            mode="gauge+number",
            value=overall_now,
            number={"suffix":" / 100"},
            title={"text": f"Overall Index – {uni} ({current_year})"},
            gauge={
                "axis":{"range":[0,100]},
                "bar":{"thickness":0.2},
                "steps":[
                    {"range":[0,50],"color":"#fce4e4"},
                    {"range":[50,75],"color":"#fff3cd"},
                    {"range":[75,100],"color":"#e8f5e9"},
                ]
            }
        ))
        gauge.update_layout(height=360, margin=dict(l=20,r=20,t=50,b=10))
        st.plotly_chart(gauge, use_container_width=True)
    else:
        st.warning("لا توجد قيمة متاحة للمؤشر الكلي في السنة المحددة.")

# 3.2 Pie – مساهمة الأنواع داخل الكلي (حسب مجموع الأوزان)
with c2:
    st.subheader("مساهمة الأنواع داخل المؤشر الكلي")
    pie_df = type_breakdown.copy()
    pie_df["function"] = pie_df["function"].map({
        "Leading":"Leading (إنذار مبكر)",
        "Concurrent":"Concurrent (تشخيص فوري)",
        "Lagging":"Lagging (قياس أثر)"
    }).fillna(pie_df["function"])

    pie = px.pie(pie_df, names="function", values="w_sum", hole=0.45,
                 title=f"توزيع الأوزان حسب النوع – {uni}")
    pie.update_layout(legend_title="", height=360, margin=dict(l=10,r=10,t=60,b=10))
    st.plotly_chart(pie, use_container_width=True)

# 3.3 Trend line – تطور المؤشر الكلي عبر السنوات
st.markdown("### الترند الزمني للمؤشر الكلي")
trend = overall_f[(overall_f["year"]>=year_start) & (overall_f["year"]<=year_end)].sort_values("year")
if not trend.empty and trend["overall_index_0_100"].notna().any():
    line = px.line(trend, x="year", y="overall_index_0_100", markers=True,
                   title=f"تطور المؤشر الكلي – {uni}")
    line.update_layout(yaxis_title="المؤشر الكلي (0–100)", xaxis_title="السنة")
    st.plotly_chart(line, use_container_width=True)
else:
    st.info("لا توجد بيانات كافية لعرض الترند في النطاق المحدد.")


# 3.4 بديل: عموديات مع تسميات
st.markdown("### تطور المؤشر الكلي عبر السنوات")
trend = overall_f[(overall_f["year"]>=year_start) & (overall_f["year"]<=year_end)].sort_values("year")
if not trend.empty and trend["overall_index_0_100"].notna().any():
    bar = px.bar(
        trend, x="year", y="overall_index_0_100",
        title=f"تطور المؤشر الكلي – {uni}", text="overall_index_0_100"
    )
    bar.update_traces(texttemplate="%{text:.1f}", textposition="outside")
    bar.update_layout(
        yaxis_title="المؤشر الكلي (0–100)",
        xaxis_title="السنة",
        uniformtext_minsize=10, uniformtext_mode='hide',
        margin=dict(l=10, r=10, t=60, b=10)
    )
    st.plotly_chart(bar, use_container_width=True)
else:
    st.info("لا توجد بيانات كافية لعرض الترند في النطاق المحدد.")

# 3.5 بديل: فروقات سنة بسنة
st.markdown("### التغير سنة بسنة (YoY)")
trend = overall_f[(overall_f["year"]>=year_start) & (overall_f["year"]<=year_end)].sort_values("year")
if len(trend) >= 2 and trend["overall_index_0_100"].notna().any():
    trend["yoy_delta"] = trend["overall_index_0_100"].diff()
    yoy = trend.dropna(subset=["yoy_delta"])
    # تلوين حسب موجب/سالب
    yoy["direction"] = np.where(yoy["yoy_delta"]>=0, "تحسن", "تراجع")
    bar_yoy = px.bar(
        yoy, x="year", y="yoy_delta", color="direction",
        color_discrete_map={"تحسن":"#2ca02c","تراجع":"#d62728"},
        title=f"التغير سنة بسنة – {uni}", text="yoy_delta"
    )
    bar_yoy.update_traces(texttemplate="%{text:.1f}", textposition="outside")
    bar_yoy.update_layout(yaxis_title="فرق النقاط عن السنة السابقة", xaxis_title="السنة")
    st.plotly_chart(bar_yoy, use_container_width=True)
else:
    st.info("يلزم توفر سنتين على الأقل لعرض التغير سنة بسنة.")

# 3.6 بديل: Sparkline + ملخص
st.markdown("### لمحة سريعة عن الاتجاه")
trend = overall_f[(overall_f["year"]>=year_start) & (overall_f["year"]<=year_end)].sort_values("year")
if not trend.empty and trend["overall_index_0_100"].notna().any():
    last = trend.iloc[-1]["overall_index_0_100"]
    prev = trend.iloc[-2]["overall_index_0_100"] if len(trend) >= 2 else np.nan
    delta = (last - prev) if pd.notna(prev) else np.nan

    k1, k2 = st.columns([1,2])
    with k1:
        st.metric("آخر قيمة", f"{last:.1f}", delta=None if pd.isna(delta) else f"{delta:+.1f}")
    with k2:
        spark = px.line(trend, x="year", y="overall_index_0_100")
        spark.update_layout(
            height=140, margin=dict(l=10,r=10,t=10,b=10),
            yaxis_title=None, xaxis_title=None
        )
        spark.update_traces(mode="lines+markers")
        st.plotly_chart(spark, use_container_width=True)
else:
    st.info("لا توجد بيانات كافية لعرض الملخص.")

# =========================
# 4) شرح مختصر
# =========================
with st.expander("ماذا يضيف قسم الطلاب؟"):
    st.markdown("""
- **إجمالي الطلاب**: يعطي حجم العينة في فترة التحليل (النطاق المختار).
- **طلاب الجامعة في السنة الحالية**: يفيد في تفسير تغيّرات المؤشر (ارتفاع/انخفاض قد يرتبط بحجم الدفعة).
- **حصة الجامعة من الإجمالي**: توضح المركز النسبي للجامعة ووزنها الوطني في نفس السنة.
- **الرسم العمودي**: مقارنة سريعة بين الجامعات في عدد الطلاب للسنة الحالية.
""")